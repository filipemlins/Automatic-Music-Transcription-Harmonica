function [TPL, ERROR_IDX] = cqt_clustering(cqt_mat, wav_files_list)
%
% Load VQT/CQT spectrograms and extracts spectral templates by clustering accordingly the F0 trajectory
% 
% inputs::
%    cqt_mat: cell_array with VQT/CQT espectrograms 
%    wav_files_list: path list of wav files which were used to extract the VQT/CQT spectrograms
%    Both input parameters are generated by the extract_cqt_from_wav_dataset function.
%
%  See also: extract_cqt_from_wav_dataset. 
%
% Created by Rodrigo Schramm on 27/09/2016.


% addpath('constant_q_toolbox/VQT');
% addpath('utils');

% due to some conflicts betweem matlab path and mirtoolbox path
%   [kmeans error -> duplicate function at:]
% might be needed removing the specific mirtoolbox path:
%  rmpath /Users/schramm/Documents/MATLAB/audio/MIRtoolbox1.6.1/netlab/

%% set 1 for parallel processing
%n_workers = 12;
% if (n_workers>1)
%     parpool(n_workers);
% end

%% create holding structure
TPL = {};

th1 = 0.07; %% minimum energy threshold (spectrum sum)
%th2 = 0.1; %% minimum energy threshold  (used to find the f0 peak)

ERROR_IDX =ones(length(cqt_mat),1);

%% loop over all files
%for uu=1:1;
%parfor uu=1:length(cqt_mat);
parfor uu=1:length(cqt_mat)
%parfor (uu=1:50, n_workers)
%for uu=1:50
    w_file=[];
    onset=[]; 
	offset=[];
	onset2=[];
	offset2=[];                
    dict = [];
    dict_cell = {};
    di = 0;
    
    try
    
    m = cqt_mat{uu};
    [fpath,fname,fext] = fileparts(wav_files_list(uu).name);
    w_file = [fname];
    
    s = sum(m);
    s = s/max(s);
    
    % avoiding small peaks
    [bb,aa]= butter(4, .1); 
    s=filtfilt(bb,aa,s);
    
    onset  = find(diff(s>th1)==1);
    offset = find(diff(s>th1)==-1);
    onset2 = [];
    offset2 = [];
    pitch = [];
    
    fprintf('File:[%d]-[%s]    #onsets [%d]\n',uu, w_file, length(onset));
    for i=1:length(onset);
        of = offset(min(find(offset>onset(i))));
        ch = [onset(i) of];
        
        
        if length(ch)<2 ||  abs(ch(1)-ch(2))<5
            continue;
        end
        
        spec_win = m(:,ch(1):ch(2));
        % avoid silence
        nul = find(sum(spec_win)<th1);
        spec_win(:,nul) = []; 
        if (isempty(spec_win)); continue; end;
        
        %% aligning sepctra by f0 peaks
        peak_area = [];
        % iterate over all spec_window
        for j=1:size(spec_win,2);
            tpl = spec_win(:,j);            
            tpl = tpl/sum(tpl);
            [x,pos] = findpeaks(tpl,'MinPeakHeight',max(tpl)*0.15);
            if length(pos)>0  peak_area= [peak_area; pos(1)]; end;
        end
        
        % fit a normal distribution for the peak (F0)
        [peak_mean,peak_var]=normfit(peak_area);
        peak_var = min(5*peak_var,30);
        
        tpl_aux=[]; % auxliar template buffer
        for j=1:size(spec_win,2);
            tpl = spec_win(:,j);
            tpl = tpl/sum(tpl);
            %% remove other peaks
            tpl(1:round(peak_mean-1*peak_var))=0;
            tpl(round(peak_mean+1*peak_var):end)=0;
            tpl_aux(j,:) =  tpl;
        end
        
        pp=[];
        base = [];
        for j=1:size(tpl_aux,1);
            c=[];
            tpl = tpl_aux(j,:);
            for ii=1:length(tpl);
                if (tpl(ii)>0);
                    c = [c; ones([round((tpl(ii)*100)),1])*ii];
                end;
            end;
            [ma,ms]=normfit(c);
            pp(j) = ma;
            base(j) = ms;
        end
        
        spec_win2=[];
        
        if 1
            d = [round(median(pp)) - pp];
            scaleFactor = 100; % allows shift with resolution of 1/scaleFactor;
            d = round(d*scaleFactor);
            
            for j=1:length(d);
                tpl = spec_win(:,j);
                tpl = imresize(tpl, [length(tpl)*scaleFactor 1]);                
                if d(j)>0
                    tpl = [zeros([d(j) 1]); tpl(1:end-d(j))];
                elseif d(j)<0 
                    tpl = [tpl(-d(j):end);  zeros([abs(d(j))-1 1])];                
                end
                %[d(j), j, length(tpl)],
                %tpl = circshift(tpl, [d(j), 0]);                
                spec_win2(:,j) = imresize(tpl, [length(tpl)/scaleFactor 1]);                
            end
            
            onset2 = [onset2, size(dict,2)+1];
            offset2 = [offset2, size(dict,2)+size(spec_win2,2)];
            dict = [dict, spec_win2];
            di =di+1;
            dict_cell{di} = spec_win2;
            pitch(di) = round(median(pp)); 
        
        else  % TODO double check if the code below is working properly.          
            %% split F0 sequence into clusters (sung notes)
            cclusters = [];
            nclusters=1;
            varF0 = std(pp);
            varThreshold = 2;
            ip=ones(size(pp));
            dcomp = [];
            % 
            while varF0>varThreshold  &&  nclusters<2
                nclusters = nclusters+1;
                ip = kmeans(pp',nclusters);
                newVar = [];
                for k=1:nclusters;
                    cclusters(k) = median(pp(ip==k));
                    newVar(k) = std(pp(ip==k));
                end
                varF0 = max(newVar);
            end
            
            jj = 0;
            
            for k=1:nclusters;
                
                
                idx_d = find(ip==k);
                %% remove small clusters
                if length(idx_d)<length(pp)*.20
                    continue;
                end
                ds = median(pp(ip==k));
                d = ds - pp;
                
                %dcomp = [dcomp; d'];
                scaleFactor = 100;
                d = round(d*scaleFactor);
                spec_winMat=[];
                for j=1:length(idx_d)
                    cc = idx_d(j);
                    tpl = spec_win(:,cc);
                    tpl = imresize(tpl, [length(tpl)*scaleFactor 1]);
                    tpl = circshift(tpl, [d(cc), 0]);
                    spec_win2(:,cc) = imresize(tpl, [length(tpl)/scaleFactor 1]);
                    spec_winMat(:,j) = spec_win2(:,cc);
                end
                di =di+1;
                dict_cell{di} = spec_winMat;
                
                onset2 = [onset2, size(dict,2)+1];
                offset2 = [offset2, size(spec_winMat,2)];
                dict = [dict, spec_winMat];
                
            end
        end        
    end
    
    if 0
        for i=1:di;
            dic =  dict_cell{i};
            if size(dic,2)<10; continue; end;
            
            [W,H] = nnmf(dict_cell{i},1);
            subplot(1,3,1);    imagesc(W);
            subplot(1,3,2);    imagesc(H);
            subplot(1,3,3);    imagesc(dict_cell{i});
            pause,
        end
    end
    
    templates = [];
    templates.m  = m;
    templates.onset = onset;
    templates.offset = offset;
    templates.dict = dict;
    templates.dict_cell = dict_cell;
    templates.onset2 = onset2;
    templates.offse2 = offset2;
    templates.pitch = pitch;
    templates.fname = w_file;
    TPL{uu} = templates;
    ERROR_IDX(uu) = 0;
    
    %fprintf('\n');
    if 0
        fig3 = figure;
        %subplot(1,2,1);
        subplot('position', [ .07 .05 .45 .95]); hold on;
        %imagesc(M(end:-1:1,:)); hold on;
        imagesc(m); hold on;
        stem(onset, ones(size(onset))*400,'g');
        stem(offset,ones(size(offset))*400,'r');
        axis off;
        %subplot(1,2,2);
        subplot('position', [ .55 .05 .45 .95]); hold on;
        %imagesc(dict(end:-1:1,:)); hold on;
        imagesc(dict); hold on;
        stem(onset2, ones(size(onset2))*400,'g');
        stem(offset2,ones(size(offset2))*400,'r');
        axis off;
        title(w_file);
        %  set(fig3, 'Position', [100, 100, 1049, 895]);
        %  set(fig3,'PaperPositionMode', 'auto') ;
        %
        set(fig3, 'Position', [ 50 223 1100 400]);
        set(fig3, 'Units', 'normalized', 'PaperPositionMode', 'auto');
        
        print(fig3, '-depsc', '-r300', '-loose',  ['plots/', w_file, '.eps']);
        close(fig3);
    end
    
    catch merror
        TPL{uu} = {};        
        fprintf('error: >>>>>>>>>>>>>>>>   File:[%d]-[%s]    #onsets [%d]\n     %s\n', uu, w_file, length(onset), merror.identifier);
        getReport(merror),
%         merror.cause{:},
%         merror.stack.file,
%         merror.stack.name,
%         merror.stack.line,
    end
    
end


%save('TPL.mat', '-v7.3', 'TPL', 'wav_files_list', 'ERROR_IDX');


